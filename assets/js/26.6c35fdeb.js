(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{429:function(t,e,v){"use strict";v.r(e);var _=v(2),r=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"有序数组的平方"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有序数组的平方"}},[t._v("#")]),t._v(" 有序数组的平方")]),t._v(" "),e("p",[t._v("这是力扣 977 题")]),t._v(" "),e("blockquote",[e("p",[t._v("给你一个按  "),e("strong",[t._v("非递减顺序")]),t._v("  排序的整数数组  "),e("code",[t._v("nums")]),t._v("，返回  "),e("strong",[t._v("每个数字的平方")]),t._v("  组成的新数组，要求也按  "),e("strong",[t._v("非递减顺序")]),t._v("  排序。")])]),t._v(" "),e("h2",{attrs:{id:"解题思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),e("p",[t._v("继上一道题使用到双指针、API、暴力解法，又刷到一道类似的题目，来巩固一下这三种解法。这题描述的很清楚，就是将一组数组里的数平方之后再通过排序输出，十分容易理解。因此，这里也可以使用到暴力配合 API 解法以及双指针解法。")]),t._v(" "),e("h3",{attrs:{id:"暴力配合-api-解法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#暴力配合-api-解法"}},[t._v("#")]),t._v(" 暴力配合 API 解法")]),t._v(" "),e("p",[t._v("暴力解法就不用我多说了吧，使用一层 "),e("code",[t._v("for")]),t._v(" 循环遍历，然后进行求平方。排序可以通过调用 "),e("code",[t._v("API")]),t._v(" 即 "),e("code",[t._v("sort")]),t._v(" 函数来解决。思路过程十分简单，看代码也是一看就会。")]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var sortedSquares = function(nums) {\n    var arr = [];\n    for(let i = 0;i<nums.length;i++){\n        arr.push(nums[i]*nums[i]);\n    }\n    let Arr = arr.sort(function(a,b){return a-b});\n    return Arr\n};\n")])])]),e("p",[t._v("这样一看暴力解法是不是很简单。但是还是存在那个问题，时间复杂度。因此，下面将来介绍双指针解法。")]),t._v(" "),e("h3",{attrs:{id:"双指针解法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双指针解法"}},[t._v("#")]),t._v(" 双指针解法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var sortedSquares = function(nums) {\n   //双指针解法\n   let n = nums.length;\n    let res = new Array(n);\n    let i = 0, j = n - 1, k = n - 1;\n    while (i <= j) {\n        let left = nums[i] * nums[i],\n            right = nums[j] * nums[j];\n        if (left < right) {\n            res[k--] = right;\n            j--;\n        } else {\n            res[k--] = left;\n            i++;\n        }\n    }\n    return res;\n};\n")])])]),e("p",[t._v("在此题中，"),e("code",[t._v("i")]),t._v(" 指向起始位置，"),e("code",[t._v("j")]),t._v(" 指向终止位置。然后定义一个新数组 "),e("code",[t._v("res")]),t._v("，和 "),e("code",[t._v("nums")]),t._v(" 数组一样的大小，让 "),e("code",[t._v("k")]),t._v(" 指向 "),e("code",[t._v("res")]),t._v(" 数组终止位置。这里输出的原则就是：因为数组是有序的，正常情况下进行平方后也是正常排序。但是负数的平方可能会成为最大值，所以需要通过比较来判断最大值是在数组的最左边还是在最右边。")]),t._v(" "),e("p",[t._v("相比较于暴力配合 API 解法，双指针解法会难理解些，但是它的时间复杂度降低了很多。因此大家可以多去尝试一下，理解双指针解法。")]),t._v(" "),e("h2",{attrs:{id:"移除数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#移除数组"}},[t._v("#")]),t._v(" 移除数组")]),t._v(" "),e("p",[t._v("这是力扣 27 题")]),t._v(" "),e("blockquote",[e("p",[t._v("给你一个数组 nums  和一个值 val，你需要 "),e("strong",[t._v("原地")]),t._v(" 移除所有数值等于  val  的元素，并返回移除后数组的新长度。"),e("br"),t._v("\n不要使用额外的数组空间，你必须仅使用 "),e("strong",[t._v("O(1)")]),t._v(" 额外空间并原地修改输入数组。"),e("br"),t._v("\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。")])]),t._v(" "),e("h2",{attrs:{id:"解题思路-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),e("p",[t._v("此题中有一个很重要的条件，"),e("strong",[t._v("你必须仅使用 O(1) 额外空间并原地修改输入数组")]),t._v("。空间复杂度 O(1)、原地移除，这都是已经规定好了的。这里将介绍双指针、API、暴力三种解法。")]),t._v(" "),e("h3",{attrs:{id:"双指针解法-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双指针解法-2"}},[t._v("#")]),t._v(" 双指针解法")]),t._v(" "),e("p",[t._v("双指针又称为快慢指针，通过一个快指针和慢指针在一个"),e("code",[t._v("for")]),t._v("循环下完成两个"),e("code",[t._v("for")]),t._v("循环的工作。快慢指针在解题中也是经常使用，掌握好它能解决很多相关问题的。")]),t._v(" "),e("p",[t._v("快慢指针的定义：")]),t._v(" "),e("ul",[e("li",[t._v("快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组")]),t._v(" "),e("li",[t._v("慢指针：指向更新 新数组下标的位置")])]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var removeElement = function(nums, val) {\n    const n = nums.length;\n    let left = 0;\n    for (let right = 0; right < n; right++) {\n        if (nums[right] !== val) {\n            nums[left] = nums[right];\n            left++;\n        }\n    }\n    return left;\n")])])]),e("h3",{attrs:{id:"api-解法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api-解法"}},[t._v("#")]),t._v(" API 解法")]),t._v(" "),e("p",[t._v("使用 "),e("strong",[t._v("js")]),t._v(" 中的数组方法 "),e("strong",[t._v("splice()")]),t._v("，对数组进行一层"),e("code",[t._v("for")]),t._v("循环即可。"),e("strong",[t._v("splice()")]),t._v(" 方法用于添加或删除数组中的元素。在循环过程中如遇到与目标值相等的元素，就可以使用 "),e("strong",[t._v("splice()")]),t._v(" 方法来删除数组的元素从而达到效果。")]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var removeElement = function(nums, val) {\n    for(var i=0;i<nums.length;i++){\n        if(nums[i]===val){\n            nums.splice(i,1)\n            i--\n        }\n    }\n    return nums.length\n};\n")])])]),e("h3",{attrs:{id:"暴力解法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#暴力解法"}},[t._v("#")]),t._v(" 暴力解法")]),t._v(" "),e("p",[t._v("暴力解法相信大家都了解或者都用过，遇事不决就暴力。暴力解法是最基本也是最简单的解题思路，但是它的缺点是时间复杂度太高了。在此题中，可以使用两层"),e("code",[t._v("for")]),t._v("循环，一层遍历数组元素，一层更新数组元素，所以时间复杂度为"),e("code",[t._v("O(n*n)")]),t._v("。（暴力解法比较普遍，所以这里就不附上代码了）")]),t._v(" "),e("h2",{attrs:{id:"二分查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二分查找"}},[t._v("#")]),t._v(" 二分查找")]),t._v(" "),e("p",[t._v("这是力扣 704 题")]),t._v(" "),e("blockquote",[e("p",[t._v("给定一个  n  个元素有序的（升序）整型数组  nums 和一个目标值  target  ，写一个函数搜索  nums  中的 target，如果目标值存在返回下标，否则返回 -1。")])]),t._v(" "),e("p",[t._v("不难看出，这是一道典型的二分查找的问题（毕竟题目名就叫二分查找）。对于二分查找，有着专门的解题思路和技巧。")]),t._v(" "),e("h2",{attrs:{id:"解题思路-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-3"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),e("p",[t._v("什么是二分法，简单点理解就是对数据进行对半查找。二分法会涉及到很多边界条件，二分法的难点就在于如何处理边界问题。例如到底是  "),e("code",[t._v("while(left < right)")]),t._v("  还是  "),e("code",[t._v("while(left <= right)")]),t._v("。")]),t._v(" "),e("p",[t._v("在二分法中区间有左闭右闭和左闭右开两种定义。下面将用这左闭右闭区间的方法来讲解一下此题。")]),t._v(" "),e("h3",{attrs:{id:"左闭右闭"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#左闭右闭"}},[t._v("#")]),t._v(" 左闭右闭")]),t._v(" "),e("p",[t._v("左闭右闭就是"),e("code",[t._v("[left,right]")]),t._v("，所以在这里需要判断是"),e("code",[t._v("while(left < right)")]),t._v("还是"),e("code",[t._v("while(left <= right)")]),t._v("。")]),t._v(" "),e("h4",{attrs:{id:"边界问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#边界问题"}},[t._v("#")]),t._v(" 边界问题")]),t._v(" "),e("p",[t._v("对于边界问题，可以这么去想：如果是"),e("code",[t._v("while(left < right)")]),t._v("，说明"),e("code",[t._v("left")]),t._v("一定是只能小于"),e("code",[t._v("right")]),t._v("的，如果是"),e("code",[t._v("while(left <= right)")]),t._v("，说明"),e("code",[t._v("left")]),t._v("等于"),e("code",[t._v("right")]),t._v("是成立的。因为我们使用左闭右闭区间，所以"),e("code",[t._v("left = right")]),t._v("，所以可以使用"),e("code",[t._v("while(left <= right)")]),t._v("。同理，如果使用左闭右开区间，就是使用"),e("code",[t._v("while(left < right)")]),t._v("，因为左闭右开区别没有"),e("code",[t._v("left = right")]),t._v("。")]),t._v(" "),e("h4",{attrs:{id:"中间值问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中间值问题"}},[t._v("#")]),t._v(" 中间值问题")]),t._v(" "),e("p",[t._v("除了"),e("code",[t._v("while")]),t._v("问题，这里还有一个"),e("code",[t._v("middle")]),t._v("问题。在左闭右闭的情况下，如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为"),e("code",[t._v("middle-1")]),t._v("；如果右边界更新为"),e("code",[t._v("middle")]),t._v("，那中间数还在下次查找范围内。在左闭右开的情况下，如果中间值大于目标值，中间值不应在下次查找的范围内，但中间值的前一个值应该要在。因为左闭右开，所以"),e("code",[t._v("right")]),t._v("不在查找范围内，所以将右边界更新为中间值，如果更新右边界为"),e("code",[t._v("mid-1")]),t._v("，则将中间值的前一个值就会查找不到了。")]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var search = function(nums, target) {\n    let left = 0;\n    let right = nums.length-1;\n    while(left<=right){\n        let middle = Math.floor((right+left)/2);\n        if(nums[middle]>target){\n            right = middle-1;\n        }else if(nums[middle]<target){\n            left = middle+1;\n        }else{\n            return middle\n        }\n    }\n    return -1;\n};\n")])])]),e("p",[t._v("了解了"),e("code",[t._v("while")]),t._v("和"),e("code",[t._v("middle")]),t._v("问题，现在来看代码是不是很容易理解了。这样一来，这个简单的二分查找就解决了。")])])}),[],!1,null,null,null);e.default=r.exports}}]);