(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{438:function(n,t,s){"use strict";s.r(t);var e=s(2),a=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"最后一个单词的长度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后一个单词的长度"}},[n._v("#")]),n._v(" 最后一个单词的长度")]),n._v(" "),t("p",[n._v("这是力扣第 58 题")]),n._v(" "),t("blockquote",[t("p",[n._v("给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。")])]),n._v(" "),t("h2",{attrs:{id:"解题思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[n._v("#")]),n._v(" 解题思路")]),n._v(" "),t("p",[n._v("这是一道简单题，题意清晰，比较容易理解，根据字符串返回最后一个单词的长度。看到这题第一眼，很显然能想到遍历字符串来实现。又因为这是字符串里包含单词且单词也是字符串，所以也可以考虑将字符串转换为数组。因此接下来会分别介绍一下这两种解题思路。")]),n._v(" "),t("h3",{attrs:{id:"遍历法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历法"}},[n._v("#")]),n._v(" 遍历法")]),n._v(" "),t("p",[n._v("这题用遍历法就很简单了。因为题目是让我们求出最后一个单词的长度，因此可以考虑反向遍历。反向遍历是怎么样的呢？我们可以从最后一个字母开始遍历字符串，由于每个单词之间都是存在空格的，所以当第一次遇到空格时，说明此时遍历到的每个字母都属于最后一个单词，因此遍历到的字母数量即为最后一个单词的长度。最后通过 "),t("code",[n._v("length")]),n._v(" 返回最终结果就行了。")]),n._v(" "),t("p",[n._v("相关代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('var lengthOfLastWord = function(s) {\n    var len=0\n    for(var i=s.length-1;i>=0;i--){\n        var char=s[i]\n        if(char!==" "){\n            len++\n        }else{\n            if(len>0) break\n        }\n    }\n    return len\n};\n')])])]),t("h3",{attrs:{id:"转换数组法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转换数组法"}},[n._v("#")]),n._v(" 转换数组法")]),n._v(" "),t("p",[n._v("除了使用遍历法，还可以通过将字符串转换为数组来解决此题。将字符串转换为数组，通过 "),t("code",[n._v("filter（）")]),n._v(" 过滤空格，最后返回最终结果即可。过程以及代码十分简单。但是相比较于这种方式，我更推荐上面的遍历法，毕竟这种方式对于这题而言还是会有点不好完全理解。")]),n._v(" "),t("p",[n._v("相关代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" var lengthOfLastWord = function (s) {\n    let str = s.split(' ');\n    str = str.filter((item) => !item);\n    return str[str.length - 1].length;\n  };\n")])])]),t("h2",{attrs:{id:"三数之和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三数之和"}},[n._v("#")]),n._v(" 三数之和")]),n._v(" "),t("p",[n._v("这是力扣第 15 题")]),n._v(" "),t("blockquote",[t("p",[n._v("给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。")])]),n._v(" "),t("h2",{attrs:{id:"解题思路-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[n._v("#")]),n._v(" 解题思路")]),n._v(" "),t("p",[n._v("这道题是一道中等难度题，在原先两数之和的基础上又加入了一个数变成三数之和，因此可以从两数之和上来突破。最容易想到的思路是，两数之和通过暴力解法即通过两层 "),t("code",[n._v("for")]),n._v(" 循环遍历数组，那么，在两层 "),t("code",[n._v("for")]),n._v(" 循环的基础上再加入一层循环即可。")]),n._v(" "),t("h3",{attrs:{id:"暴力解法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#暴力解法"}},[n._v("#")]),n._v(" 暴力解法")]),n._v(" "),t("p",[n._v("暴力解法不用多说，只需三层 "),t("code",[n._v("for")]),n._v(" 循环即可。暴力解法的本质就是 "),t("code",[n._v("for")]),n._v(" 循环，通过层层循环来到达预期结果，不过在时间复杂度上会差强人意，不如其他的方法。")]),n._v(" "),t("p",[n._v("相关代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var threeSum = function(nums) {\n    for(let i=0;i<nums.length;i++){\n        let currt = nums[i];\n        for(let j=i+1;j<nums.length;j++){\n            for(let l=j+1;j<nums.length;l++){\n                let sum=nums[j]+nums[l];\n            }\n        }\n        if(currt+sum===0){\n            return [nums[i],nums[j],nums[l]]\n        }else{\n            return false;\n        }\n    }\n};\n")])])]),t("h3",{attrs:{id:"双指针法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双指针法"}},[n._v("#")]),n._v(" 双指针法")]),n._v(" "),t("p",[n._v("在两数之和中，可以使用双指针法来解决，那么，对于三数之和，是否也可以使用同种方法呢？当然是可以的。之前就有提到过，双指针法比较重要，掌握好双指针能解决很多题目。")]),n._v(" "),t("p",[n._v("对数组进行排序，排序后固定一个数 "),t("code",[n._v("nums[i]")]),n._v("，再使用左右指针指向 "),t("code",[n._v("nums[i]")]),n._v(" 后面的两端，数字分别为 "),t("code",[n._v("nums[L]")]),n._v(" 和 "),t("code",[n._v("nums[R]")]),n._v("，计算三个数的和 "),t("code",[n._v("sum")]),n._v(" 判断是否满足为 0。")]),n._v(" "),t("p",[n._v("相关代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var threeSum = function(nums) {\n    let ans = [];\n    const len = nums.length;\n    if(nums == null || len < 3) return ans;\n    nums.sort((a, b) => a - b); // 排序\n    for (let i = 0; i < len ; i++) {\n        if(nums[i] > 0) break;\n        if(i > 0 && nums[i] == nums[i-1]) continue;\n        let L = i+1;\n        let R = len-1;\n        while(L < R){\n            const sum = nums[i] + nums[L] + nums[R];\n            if(sum == 0){\n                ans.push([nums[i],nums[L],nums[R]]);\n                while (L<R && nums[L] == nums[L+1]) L++;\n                while (L<R && nums[R] == nums[R-1]) R--;\n                L++;\n                R--;\n            }\n            else if (sum < 0) L++;\n            else if (sum > 0) R--;\n        }\n    }\n    return ans;\n};\n")])])]),t("p",[n._v("这就是双指针法，相比较暴力法可能理解起来会有些难度，但是从时间复杂度上来说会降低很多，所以可以多分析分析这题，对理解双指针法有很大好处。")]),n._v(" "),t("h2",{attrs:{id:"两数之和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两数之和"}},[n._v("#")]),n._v(" 两数之和")]),n._v(" "),t("p",[n._v("这是力扣第 1 题")]),n._v(" "),t("blockquote",[t("p",[n._v("给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那   两个   整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。")])]),n._v(" "),t("h2",{attrs:{id:"解题思路-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-3"}},[n._v("#")]),n._v(" 解题思路")]),n._v(" "),t("p",[n._v("两数之和，第一题力扣，这是多少人第一次刷题的回忆，我相信 90% 的人的第一次刷题记忆是从这道题开始的。毫无例外，我也是从这题开始的，因此这题也是十分经典（毕竟是我们梦开始的地方 😎）。题目有非常多的解法，最简单直接的无疑是暴力解法。接下来就来介绍一下以下几种方法。")]),n._v(" "),t("h3",{attrs:{id:"暴力解法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#暴力解法-2"}},[n._v("#")]),n._v(" 暴力解法")]),n._v(" "),t("p",[n._v("暴力解法十分简单，只需通过两层循环遍历数组找到 "),t("code",[n._v("target")]),n._v(" 即可。这道题用暴力解法是特别容易理解的（遇题不会就暴力 😎）。整体解题思路如下：")]),n._v(" "),t("ul",[t("li",[n._v("两次 "),t("code",[n._v("for")]),n._v(" 循环，第一次 "),t("code",[n._v("for")]),n._v(" 循环遍历取当前元素值，第二次 "),t("code",[n._v("for")]),n._v(" 循环遍历取下一元素的值，")]),n._v(" "),t("li",[n._v("然后判断两个元素的和是否等于目标结果，并记录结果索引到数组。")])]),n._v(" "),t("p",[n._v("相关代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var twoSum = function(nums, target) {\n    for(let i = 0, len = nums.length;i < len;i++){\n        for(let j = i + 1;j < len;j++) {\n            if(nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    return [-1, -1];\n};\n")])])]),t("h3",{attrs:{id:"其他解法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他解法"}},[n._v("#")]),n._v(" 其他解法")]),n._v(" "),t("p",[n._v("这道题有很多其他解法，大家可以去多看看。这里我就附上一种其他思路的代码，具体思路和暴力解法大差不差，大家可以多多研究一下，理清楚其中的奥妙。")]),n._v(" "),t("p",[n._v("相关代码如下：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var twoSum = function(nums, target) {\n    var indexarr =[];\n   for(var i =0; i<nums.length; i++){\n       var targetIndex = nums.indexOf(target-  nums[i]);\n        if(targetIndex!=-1&&targetIndex!==i){\n            indexarr=[i,targetIndex]\n        break;\n        }\n   }\n    return indexarr\n};\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);