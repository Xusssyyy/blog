(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{437:function(t,e,r){"use strict";r.r(e);var a=r(2),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"x-的平方根"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#x-的平方根"}},[t._v("#")]),t._v(" X 的平方根")]),t._v(" "),e("p",[t._v("这是力扣第 69 题")]),t._v(" "),e("blockquote",[e("p",[t._v("给你一个非负整数 x ，计算并返回  x  的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。")])]),t._v(" "),e("h2",{attrs:{id:"解题思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),e("p",[t._v("这是一道简单题，第一眼看过去，是不是觉得和上次那道 Pow（x，n）很像，但是又不完全一样。在这里题目中已经指明了不能使用库函数，因此这题的本质就和 Pow（x，n）那道题一样，让我们自己手写一个函数来解决相关问题。有了那次的经验，写这种函数的题目应该是十分轻松的。我们只需找到两个关键点，一是对应什么函数，二是如何运行出结果。")]),t._v(" "),e("h3",{attrs:{id:"二分法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二分法"}},[t._v("#")]),t._v(" 二分法")]),t._v(" "),e("p",[t._v("可能很多人都没能想到，这是一道可以用二分查找的题目，但是这题用二分法来解决是最好的思路了。二分法就不用再做介绍了吧，之前已经讲过很多次了。二分法的精髓在于判断中间值大于左边还是大于右边以及是否取中间值，这些在之前的文章里已经讲得很清楚了，新来的小伙伴们可以再去看看。")]),t._v(" "),e("p",[t._v("对于这题而言，我们首先需要从数组的中间元素开始查找，如果这个中间元素是我们所需要的目标值，就结束查找，否则就继续查找。如果目标值小于或者大于中间元素，则在数组中小于或者大于中间元素的剩下区域里继续查找，并重复前面的操作。这就是二分法在此题里的思路。")]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var mySqrt = function(x) {\n    if (x < 2) return x\n    let left = 1;\n    let right = Math.floor(x / 2);\n    while (left <= right) {\n        const mid = Math.floor(left + (right - left) / 2)\n        if (mid * mid === x) return mid\n        if (mid * mid < x) {\n            left = mid + 1\n        }else {\n            right = mid - 1\n        }\n    }\n    return right\n")])])]),e("h2",{attrs:{id:"对称二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称二叉树"}},[t._v("#")]),t._v(" 对称二叉树")]),t._v(" "),e("p",[t._v("这是力扣 101 题")]),t._v(" "),e("blockquote",[e("p",[t._v("给你一个二叉树的根节点  "),e("code",[t._v("root")]),t._v(" ， 检查它是否轴对称。")])]),t._v(" "),e("h2",{attrs:{id:"解题思路-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),e("p",[t._v("经历了数组、链表的环节，现在来看看二叉树相关的题目。\n先来介绍一下二叉树吧，二叉树有两种主要的形式：满二叉树和完全二叉树。\n其实很多人会分不清楚满二叉树和完全二叉树。最开始接触的时候我也会分不清楚，但是这不重要，重要的是不知道的时候我就会去查找它们的概念，对比它们的区别，来加强对它们的印象，最后通过多做题来熟能生巧。")]),t._v(" "),e("p",[t._v("看到这道题目，首先我们可以考虑将题目意思转换一下。一个树是对称的，所以它的左右子树也一定是对称的，进而就可以推导出当根节点的值是相同的时候，一个树的右子树和另一个树的左子树对称。因此，这里将引出递归法解决此题。")]),t._v(" "),e("h3",{attrs:{id:"递归法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#递归法"}},[t._v("#")]),t._v(" 递归法")]),t._v(" "),e("p",[t._v("递归法在二叉树的题目中很常用，递归思想在二叉树中极其普遍，所以需要掌握。接下来介绍一下此题的解题思路：如果两个子树都为 null，是对称的；如果两个子树都存在，则需要 root 值相同；如果一个子树存在一个不存在，肯定是不对称的；如果传入的 root 就是 null，则是对称的，否则，判断它的左右子树是否满足对称。")]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const isSymmetric = (root) => {\n    const check = (left, right) => {\n        if (left == null && right == null) {\n           return true;\n        }\n        if (left && right) {\n            return left.val == right.val && check(left.left, right.right) && check(left.right, right.left);\n        }\n        return false;\n    };\n\n    if (root == null) {\n        return true;\n    }\n    return check(root.left, root.right);\n};\n")])])]),e("p",[t._v("对于二叉树的题目，我的建议是多看看关于不同的二叉树的概念以及在写题的过程中多画图，这样会使思路更清晰。")]),t._v(" "),e("h2",{attrs:{id:"反转字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#反转字符串"}},[t._v("#")]),t._v(" 反转字符串")]),t._v(" "),e("p",[t._v("这是力扣 344 题")]),t._v(" "),e("blockquote",[e("p",[t._v("编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。")])]),t._v(" "),e("h2",{attrs:{id:"解题思路-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-3"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),e("p",[t._v("这是一道非常简单的题目，写过这道题的人也是非常多，因此这道题也有非常多的解法。所以接下来将介绍一些我个人认为比较经典的解法。")]),t._v(" "),e("h3",{attrs:{id:"api-解法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#api-解法"}},[t._v("#")]),t._v(" API 解法")]),t._v(" "),e("p",[t._v("这个解法属于特别离谱的那种，我们直接调用 "),e("code",[t._v("JS")]),t._v(" 自带的 "),e("code",[t._v("API")]),t._v(" 即可。")]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var reverseString = function(s) {\n    s.reverse();\n};\n")])])]),e("p",[t._v("一行代码，就能解决这题，大家说离谱不离谱。这就是 "),e("code",[t._v("JS")]),t._v(" 的魅力。但是使用 "),e("code",[t._v("API")]),t._v(" 解题并不是终点，只是解题的一个过程（大家就当图一乐，实在想不到其他方法再去选择用它）。接下来就来介绍一下更合理的解法。")]),t._v(" "),e("h3",{attrs:{id:"双指针法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双指针法"}},[t._v("#")]),t._v(" 双指针法")]),t._v(" "),e("p",[t._v("调用 "),e("code",[t._v("API")]),t._v(" 固然很快乐，但是对思维得不到充分的锻炼。其实这道题不难想到可以用双指针法。双指针法太常用了，所以请大家务必要掌握。对于长度为 "),e("code",[t._v("N")]),t._v(" 的即将被反转的字符数组，我们来观察一下反转前后下标的变化。假设反转前字符数组为 s[0]，s[1]，...s[N - 1]，那么反转后字符数组为 s[N - 1]，s[N - 2]，... s[0]。比较反转前后下标变化很容易得出 s[i] 的字符与 s[N - 1 - i] 的字符发生了交换的规律。")]),t._v(" "),e("p",[t._v("所以对于这题，双指针的思路如下：")]),t._v(" "),e("ul",[e("li",[t._v("将 "),e("code",[t._v("left")]),t._v(" 指向字符数组首元素，"),e("code",[t._v("right")]),t._v(" 指向字符数组尾元素。")]),t._v(" "),e("li",[t._v("当 "),e("code",[t._v("left")]),t._v(" < "),e("code",[t._v("right")]),t._v("，交换 s[left] 和 s[right]；")]),t._v(" "),e("li",[t._v("当 "),e("code",[t._v("left")]),t._v(" >= "),e("code",[t._v("right")]),t._v("，反转结束，返回字符数组即可")])]),t._v(" "),e("p",[t._v("相关代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var reverseString = function(s) {\n  let start = 0;\n  let end = s.length - 1;\n  while (start < end) {\n    [s[start], s[end]] = [s[end], s[start]];\n    start++;\n    end--;\n  }\n  return s;\n};\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);