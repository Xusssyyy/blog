(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{431:function(e,t,v){"use strict";v.r(t);var r=v(2),_=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"翻转链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#翻转链表"}},[e._v("#")]),e._v(" 翻转链表")]),e._v(" "),t("p",[e._v("这是力扣 206 题")]),e._v(" "),t("blockquote",[t("p",[e._v("给你单链表的头节点  "),t("code",[e._v("head")]),e._v(" ，请你反转链表，并返回反转后的链表。")])]),e._v(" "),t("h2",{attrs:{id:"解题思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[e._v("#")]),e._v(" 解题思路")]),e._v(" "),t("p",[e._v("反转链表大致是如下所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f134dea181d1493cb955e1b41197bd1a~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),t("p",[e._v("从上图可以清晰地知道，只需要改变链表的 "),t("code",[e._v("next")]),e._v(" 指针的指向就可以将链表反转。除此之外，还有一种方法，就是定义一个新的链表，但是这种不是特别推荐，因为需要新的链表，所以会浪费内存空间。至于应该如何改变链表的 "),t("code",[e._v("next")]),e._v(" 指针的指向，接下来就来详细介绍一下。")]),e._v(" "),t("p",[e._v("和大部分的链表题目一样，我们可以先把头节点保存下来。首先我们需要定义一个 "),t("code",[e._v("current")]),e._v(" 指针，让它指向头节点，再定义一个 "),t("code",[e._v("pre")]),e._v(" 指针，并初始化为 "),t("code",[e._v("null")]),e._v("。然后就可以开始反转了。首先要把 "),t("code",[e._v("current->next")]),e._v(" 节点用 "),t("code",[e._v("tmp")]),e._v(" 指针保存一下，也就是保存一下这个节点。")]),e._v(" "),t("p",[e._v("为什么要保存一下这个节点呢？因为接下来要改变 "),t("code",[e._v("current->next")]),e._v(" 的指向了，将 "),t("code",[e._v("current->next")]),e._v(" 指向 "),t("code",[e._v("pre")]),e._v("，此时已经反转了第一个节点了。接下来就是循环了，继续移动 "),t("code",[e._v("pre")]),e._v(" 和 "),t("code",[e._v("current")]),e._v(" 指针。当 "),t("code",[e._v("current")]),e._v(" 指针指向 "),t("code",[e._v("null")]),e._v(" 的时候，说明链表反转完毕。最后，只需 "),t("code",[e._v("return pre")]),e._v(" 指针就可以了，"),t("code",[e._v("pre")]),e._v(" 指针就指向了新的头节点。")]),e._v(" "),t("p",[e._v("这个也可以称为双指针法，因为已经定义好且在不断地移动 "),t("code",[e._v("pre")]),e._v(" 和 "),t("code",[e._v("current")]),e._v(" 这两个指针。")]),e._v(" "),t("p",[e._v("相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var reverseList = function(head) {\n    let current = head;\n    let pre = null;\n    let temp = null;\n    while(current){\n        temp=current.next;\n        current.next = pre;\n        pre = current;\n        current = temp;\n    }\n    return pre\n};\n")])])]),t("p",[e._v("代码非常简短且通俗易懂。并且结合上面的解释一起来看代码也是十分容易理解。相信通过这道题可以强化大家对链表的理解。")]),e._v(" "),t("h2",{attrs:{id:"移除链表元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#移除链表元素"}},[e._v("#")]),e._v(" 移除链表元素")]),e._v(" "),t("p",[e._v("这是力扣 203 题")]),e._v(" "),t("blockquote",[t("p",[e._v("给你一个链表的头节点  "),t("code",[e._v("head")]),e._v("  和一个整数  "),t("code",[e._v("val")]),e._v(" ，请你删除链表中所有满足  "),t("code",[e._v("Node.val == val")]),e._v("  的节点，并返回  "),t("strong",[e._v("新的头节点")]),e._v(" 。")])]),e._v(" "),t("h2",{attrs:{id:"解题思路-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[e._v("#")]),e._v(" 解题思路")]),e._v(" "),t("p",[e._v("前面讲了那么多数组相关的题目，现在终于到链表的环节了。这是一道很简单很基础的与链表相关的题目，接下来将会通过这道题来带大家简单地认识一下链表以及链表相关的知识。")]),e._v(" "),t("p",[e._v("什么是链表？链表是一种非连续的存储结构，它由一系列节点构成，链表中的每一个元素称为节点。节点又包括两部分，一是存储此节点数据的数据域，二是存储下一个节点地址的指针域。")]),e._v(" "),t("p",[e._v("那么，数组和链表有什么区别呢？从概念上看，数组在内存中是连续的，链表是不连续的。数组有下标，链表没有下标。数组静态分配内存，链表动态分配内存。")]),e._v(" "),t("p",[e._v("回归到本题上，它让我们移除链表元素，如果是移除数组元素，调用数组的 "),t("code",[e._v("API")]),e._v(" 以及加上其他的操作即可，但是链表不一样，它不像数组一样是连续存储的。用大白话来讲，移除链表的某一个元素后，还需将它连接起来。所以，链表有它自己特有的方式来移除元素。")]),e._v(" "),t("p",[e._v("相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var removeElements = function(head, val) {\n    const ret = new ListNode(0, head);\n    let cur = ret;\n    while(cur.next) {\n        if(cur.next.val === val) {\n            cur.next =  cur.next.next;\n            continue;\n        }\n        cur = cur.next;\n    }\n    return ret.next;\n};\n")])])]),t("p",[e._v("首先设置一个虚拟头节点，将原链表的头节点赋值给虚拟头节点。然后通过 "),t("code",[e._v("while")]),e._v(" 循环，当当前节点的值与题目所给的目标值相等时，就将当前节点的下一个节点的值赋给当前节点，并且继续循环。最后 "),t("code",[e._v("return")]),e._v(" 返回最终值的时候，是 "),t("code",[e._v("return ret.next")]),e._v("。在链表中区分并理解好指针域和数据域，这题就能很好想清楚了。")]),e._v(" "),t("h2",{attrs:{id:"长度最小的子数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#长度最小的子数组"}},[e._v("#")]),e._v(" 长度最小的子数组")]),e._v(" "),t("p",[e._v("这是力扣 209 题")]),e._v(" "),t("blockquote",[t("p",[e._v("给定一个含有  n  个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组  [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。")])]),e._v(" "),t("h2",{attrs:{id:"解题思路-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-3"}},[e._v("#")]),e._v(" 解题思路")]),e._v(" "),t("p",[e._v("这道题一眼看过去或许会看不明白，当看了例子之后才理解了。就是找出数组中之和小于 "),t("code",[e._v("target")]),e._v(" 且长度最小的一组子数组。碰到数组类型问题，当一时半会没有思路时，二话不说就可以先暴力求解一番。这里用暴力是可以的，不过这道题可以用另一种更好的思路 —— 滑动窗口。接下来就来介绍一下滑动窗口这一解法。")]),e._v(" "),t("h3",{attrs:{id:"滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[e._v("#")]),e._v(" 滑动窗口")]),e._v(" "),t("p",[e._v("在数组中，还有一个十分重要的操作：滑动窗口。这个方法在数组中被使用到的频率是非常高的，因此掌握滑动窗口至关重要，能解决很多数组问题。什么是滑动窗口，滑动窗口就是通过不断调节起始位置和终止位置，来得到最终的效果。其实如果了解双指针的话，会发现它和双指针有一点点相似，但又不完全像。在某些方面上我会把它当做双指针来理解，毕竟都是需要移动的。")]),e._v(" "),t("p",[e._v("这道题如果使用暴力解法，需要两个 "),t("code",[e._v("for")]),e._v(" 循环来完成。若在滑动窗口中，用一个 "),t("code",[e._v("for")]),e._v(" 循环即可。使用滑动窗口，需要确定如下三点：")]),e._v(" "),t("ul",[t("li",[e._v("窗口是什么")]),e._v(" "),t("li",[e._v("窗口的起始位置如何移动")]),e._v(" "),t("li",[e._v("窗口的结束位置如何移动")])]),e._v(" "),t("p",[e._v("既然是滑动窗口，首先我们要找到窗口。窗口就是满足其和 "),t("code",[e._v("≥ s")]),e._v(" 且长度最小的连续子数组。然后窗口的起始位置如何移动：如果当前窗口的值大于 "),t("code",[e._v("s")]),e._v(" 了，窗口就要向前移动了。窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是 "),t("code",[e._v("for")]),e._v(" 循环里的索引。")]),e._v(" "),t("p",[e._v("相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var minSubArrayLen = function(target, nums) {\n    const len = nums.length;\n    let l = r = sum = 0,\n        res = len + 1;\n    while(r < len) {\n        sum += nums[r++];\n        // 窗口滑动\n        while(sum >= target) {\n            res = res < r - l ? res : r - l;\n            sum-=nums[l++];\n        }\n    }\n    return res > len ? 0 : res;\n};\n")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);