(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{435:function(t,a,n){"use strict";n.r(a);var r=n(2),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"字符串相加"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串相加"}},[t._v("#")]),t._v(" 字符串相加")]),t._v(" "),a("p",[t._v("这是力扣第 415 题")]),t._v(" "),a("blockquote",[a("p",[t._v("给定两个字符串形式的非负整数  num1 和 num2 ，计算它们的和并同样以字符串形式返回。\n你不能使用任何内建的用于处理大整数的库（比如 BigInteger），  也不能直接将输入的字符串转换为整数形式。")])]),t._v(" "),a("h2",{attrs:{id:"解题思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),a("p",[t._v("这是一道简单题，比较容易想清楚如何解决它。从简单的层面理解，我们可以把字符串相加看成是整数相加，进而可以得出第一种思路 —— 将字符串转换成整数进行相加。除此之外，还可以用双指针来实现相加，第二种思路双指针法就这样产生了。接下来就来介绍这两种方法。")]),t._v(" "),a("h3",{attrs:{id:"字符串转换成数字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串转换成数字"}},[t._v("#")]),t._v(" 字符串转换成数字")]),t._v(" "),a("p",[t._v("这种方法十分简单且容易理解，将字符串转换为数字，再对它进行相加，最终返回结果的时候再转换为字符串类型即可。思路方面上没有什么难点可言。")]),t._v(" "),a("p",[t._v("相关代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var addStrings = function (num1, num2) {\nnum1 = BigInt(num1)\nnum2 = BigInt(num2)\nreturn String(num1 + num2)\n};\n")])])]),a("h3",{attrs:{id:"双指针法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双指针法"}},[t._v("#")]),t._v(" 双指针法")]),t._v(" "),a("p",[t._v("用双指针来模拟两数计算，从而达到字符串相加的效果。整体思路如下：")]),t._v(" "),a("p",[t._v("首先分别创建两个指针 "),a("code",[t._v("i")]),t._v(" 和 "),a("code",[t._v("j")]),t._v("，指针 "),a("code",[t._v("i")]),t._v(" 指向 "),a("code",[t._v("nums1")]),t._v(" 末位数字，指针 "),a("code",[t._v("j")]),t._v(" 指向 "),a("code",[t._v("nums2")]),t._v(" 末位数字。\n然后用 "),a("code",[t._v("carry")]),t._v(" 来记录进位值，没有进位则为 "),a("code",[t._v("0")]),t._v("。\n如果在遍历过程中产生进位，则让当前数字变为 "),a("code",[t._v("(i+j)%10")]),t._v(" 的值。\n如果在遍历过程中 "),a("code",[t._v("nums1")]),t._v(" 或 "),a("code",[t._v("nums2")]),t._v(" 当前已经没有数字了，就用 "),a("code",[t._v("0")]),t._v(" 来进行补位。\n最后返回最终相加的结果即可。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var addStrings = function(num1, num2) {\n    let i = num1.length - 1,\n        j = num2.length - 1,\n        carry = 0,\n        ans = [];\n    while(i >= 0 || j >= 0 || carry !== 0){\n        let c1 = i >= 0 ? num1.charAt(i) - '0' : 0,\n            c2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n        let sum = c1 + c2 + carry;\n        ans.push(sum % 10);\n        carry = Math.floor(sum / 10);\n        i--;\n        j--;\n    }\n    return ans.reverse().join('');\n};\n")])])]),a("h2",{attrs:{id:"二叉树的最小深度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最小深度"}},[t._v("#")]),t._v(" 二叉树的最小深度")]),t._v(" "),a("p",[t._v("这是力扣 111 题")]),t._v(" "),a("blockquote",[a("p",[t._v("给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。")]),t._v(" "),a("p",[a("strong",[t._v("说明：")]),t._v(" 叶子节点是指没有子节点的节点。")])]),t._v(" "),a("h2",{attrs:{id:"解题思路-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),a("p",[t._v("之前看过一道二叉树最大深度的题目，现在这是一道二叉树最小深度的题目。第一眼看过去感觉两者都差不多，不过其实从本质上看还是差不少的。用前序遍历和后序遍历都可以解决此题，前序求的是深度，后序求的是高度。但是这里需要注意一点题目中所定义的最小深度的概念，"),a("strong",[t._v("最小深度是从根节点到最近叶子节点的最短路径上的节点数量。")]),t._v(" 因此如果某一侧没有子节点，这种情况是不算的。")]),t._v(" "),a("h3",{attrs:{id:"递归解法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归解法"}},[t._v("#")]),t._v(" 递归解法")]),t._v(" "),a("p",[t._v("二叉树的问题都有递归性，因此看到二叉树的题目，二话不说就是递归解法，递归解法的整体思路如下：")]),t._v(" "),a("ul",[a("li",[t._v("左子树为空，返回右子树最小深度+1")]),t._v(" "),a("li",[t._v("右子树为空，返回左子树最小深度+1")]),t._v(" "),a("li",[t._v("左右子树均不空，返回左子树、右子树最小深度的最小值+1")]),t._v(" "),a("li",[t._v("根节点为空返回 null")])]),t._v(" "),a("p",[t._v("这样仅仅靠看会有点不好理解，因此直接来看代码吧，如果还是不好理解的话可以画图表示一下。")]),t._v(" "),a("p",[t._v("相关代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var minDepth = function(root) {\n    if(!root) return 0;\n    if(root.left === null) {\n        return minDepth(root.right) + 1\n    }\n    if(root.right === null) {\n        return minDepth(root.left) + 1\n    }\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n}\n")])])]),a("p",[t._v("这种解法又称为广度优先遍历，广度优先遍历是遍历整棵树，时间复杂度为 O(n)，空间复杂度也是 O(n)，n 为树的节点数量。如果可以找到某一个叶子节点，直接返回这个叶子节点的深度，这就是广度优先遍历。")]),t._v(" "),a("h2",{attrs:{id:"平衡二叉树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树"}},[t._v("#")]),t._v(" 平衡二叉树")]),t._v(" "),a("p",[t._v("这是力扣 110 题")]),t._v(" "),a("blockquote",[a("p",[t._v("给定一个二叉树，判断它是否是高度平衡的二叉树。")]),t._v(" "),a("p",[t._v("本题中，一棵高度平衡二叉树定义为： 一个二叉树"),a("em",[t._v("每个节点")]),t._v(" 的左右两个子树的高度差的绝对值不超过 1 。")])]),t._v(" "),a("h2",{attrs:{id:"解题思路-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-3"}},[t._v("#")]),t._v(" 解题思路")]),t._v(" "),a("p",[t._v("这是一道简单题，题目中给了高度平衡的定义：一个二叉树每个节点的左右子树的高度差的绝对值不超过 1。")]),t._v(" "),a("p",[t._v("首先我们要先明确两个概念 —— 二叉树节点的深度和高度。很多人会对这两个概念模棱两可，就分不清满二叉树和完全二叉树一样。")]),t._v(" "),a("ul",[a("li",[t._v("二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。")]),t._v(" "),a("li",[t._v("二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。")])]),t._v(" "),a("p",[t._v("另外，求二叉树深度可以从上到下去查，需要前序遍历；求高度只能从下到上去查，需要后序遍历。了解清楚这些，下面来介绍一下相关解题思路了。")]),t._v(" "),a("h3",{attrs:{id:"暴力递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#暴力递归"}},[t._v("#")]),t._v(" 暴力递归")]),t._v(" "),a("p",[t._v("暴力解法的解题思路如下：")]),t._v(" "),a("p",[t._v("首先遍历二叉树，然后对每一个节点计算左右的最大高度，计算一棵二叉树的最大深度需要递归遍历这棵二叉树的所有节点。所以如果对每个节点都进行一遍遍历，会增加时间复杂度。")]),t._v(" "),a("p",[t._v("相关代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var isBalanced = function (root) {\n  let flag = true;\n  const maxDepth = (root) => {\n    if (root == null) return 0;\n    if (!flag) return;\n    let leftMaxDepth = maxDepth(root.left);\n    let rightMaxDepth = maxDepth(root.right);\n    if (Math.abs(rightMaxDepth - leftMaxDepth) > 1) {\n      flag = false;\n    }\n    return 1 + Math.max(leftMaxDepth, rightMaxDepth);\n  };\n  maxDepth(root);\n  return flag;\n};\n")])])]),a("h3",{attrs:{id:"优化递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化递归"}},[t._v("#")]),t._v(" 优化递归")]),t._v(" "),a("p",[t._v("由于暴力递归复杂度较高，因此有了如下优化递归的方案。")]),t._v(" "),a("p",[t._v("通过后序遍历来遍历二叉树，并返回子树最大高度，从而判定每个子树是不是平衡树。如果平衡，则通过它们的高度来判断父节点是否平衡，并计算父节点的高度。")]),t._v(" "),a("p",[t._v("相关代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var isBalanced = function (root) {\n    return balanced(root) !== -1\n};\nvar balanced = function (node) {\n    if (!node) return 0\n    const left = balanced(node.left)\n    const right = balanced(node.right)\n    if (left === -1 || right === -1 || Math.abs(left - right) > 1) {\n        return -1\n    }\n    return Math.max(left, right) + 1\n}\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);