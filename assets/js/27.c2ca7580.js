(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{428:function(v,e,_){"use strict";_.r(e);var t=_(2),r=Object(t.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"删除字符串中的所有相邻重复项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除字符串中的所有相邻重复项"}},[v._v("#")]),v._v(" 删除字符串中的所有相邻重复项")]),v._v(" "),e("p",[v._v("这是力扣 1047 题")]),v._v(" "),e("blockquote",[e("p",[v._v("给出由小写字母组成的字符串  S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。")]),v._v(" "),e("p",[v._v("在 S 上反复执行重复项删除操作，直到无法继续删除。")]),v._v(" "),e("p",[v._v("在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。")])]),v._v(" "),e("h2",{attrs:{id:"解题思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[v._v("#")]),v._v(" 解题思路")]),v._v(" "),e("p",[v._v("这是一道简单题，也是一道关于栈的字符串题目。一眼看过去，感觉没什么难点，十分简单，但是这里有一个需要注意的地方，如果删除一对重复项，可能会导致新的重复项出现，所以这里我们还需要有一步保存当前字符串的步骤，这样才能使它能有效进行下去。")]),v._v(" "),e("p",[v._v("栈的解法在上一篇提到过，并且也是应用在字符串题目中，由此可见栈与字符串有着千丝万缕的联系。因此对于这道题，显而易见用栈的方法来解决此题是最好的选择。")]),v._v(" "),e("h3",{attrs:{id:"栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),e("p",[v._v("利用栈的思想来解决此题，定义一个新的数组，通过循环遍历每一个参数。如果该字符和结果数组的最后一个元素相符，则将结果数组的栈顶元素弹出，最后返回栈的字符串格式，否则将遍历到的这个字符放入到结果数组中。\n简化一下整体思路大致如下：")]),v._v(" "),e("ul",[e("li",[v._v("初始化栈并循环遍历字符串")]),v._v(" "),e("li",[v._v("如果字符串某个值和栈顶元素相符，则出栈，否则将其入栈")]),v._v(" "),e("li",[v._v("最后返回栈的字符串格式")])]),v._v(" "),e("p",[v._v("相关代码如下：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v('var removeDuplicates = function(s) {\n    let stack = [];\n    for(let item of s){\n        if(stack[stack.length - 1] === item){\n            stack.pop();\n        }else{\n            stock.push(item);\n        }\n    }\n    return stack.join("");\n};\n')])])]),e("p",[v._v("这样的解法达到的时间复杂度是 O(n)，因为只循环遍历了一次。从时间复杂度上看，这是关于此题的最好解法，大家可以多研究一下。")]),v._v(" "),e("hr"),v._v(" "),e("h2",{attrs:{id:"回文数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回文数"}},[v._v("#")]),v._v(" 回文数")]),v._v(" "),e("p",[v._v("这是力扣第 9 题")]),v._v(" "),e("blockquote",[e("p",[v._v("给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n例如，121 是回文，而 123 不是。")])]),v._v(" "),e("h2",{attrs:{id:"解题思路-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[v._v("#")]),v._v(" 解题思路")]),v._v(" "),e("p",[v._v("回文数的定义是指正序（从左向右）和倒序（从右向左）读都是一样的整数。这是一道简单题，不难。我看到此题第一眼，就有一种思路浮现 —— 整数转换数组。可能是上一篇文章写的是有关整数反转类型的题目，和这题性质一样，所以首先就想到了这种方法。因此就来介绍一下我所想到的几种方法。")]),v._v(" "),e("h3",{attrs:{id:"整数转换数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整数转换数组"}},[v._v("#")]),v._v(" 整数转换数组")]),v._v(" "),e("p",[v._v("这是我首先想到的一种思路，就是将整数转换为数组后，然后进行循环遍历，来判断是否是回文数。")]),v._v(" "),e("p",[v._v("通过 "),e("code",[v._v("toString")]),v._v(" 方式转换成数组后，开启循环遍历，如果第 "),e("code",[v._v("i")]),v._v(" 个（"),e("code",[v._v("i")]),v._v(" 从 "),e("code",[v._v("0")]),v._v(" 开始计数）和数组第 "),e("code",[v._v("len")]),v._v(" 个（"),e("code",[v._v("len")]),v._v(" 是数组长度）相等，则以此循环，"),e("code",[v._v("i")]),v._v(" 不断加一，"),e("code",[v._v("len")]),v._v(" 不断减一，这样就可以判断是否是回文数了。从另一个角度理解，判断是否是回文数就是判断数组是否对称即可。")]),v._v(" "),e("p",[v._v("相关代码如下：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("var isPalindrome = function(x) {\n    let arry = x.toString().split('');\n    let len = arry.length-1\n    for(let i = 0;i<arry.length;i++){\n        if(arry[i]==arry[len]){\n            len--;\n        }else{\n            return false;\n        }\n    }\n    return true;\n};\n")])])]),e("p",[v._v("这种思路是非常容易理解的。")]),v._v(" "),e("h3",{attrs:{id:"数学法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数学法"}},[v._v("#")]),v._v(" 数学法")]),v._v(" "),e("p",[v._v("这种方法就比较有技巧了。就和字符串一样，既然字符串可以直接反转，为何不考虑直接让数字直接反转呢？所以，数学逻辑能力比较强的同学可以想到这种方式。数字的直接反转思路如下：")]),v._v(" "),e("ul",[e("li",[v._v("我们拿 "),e("code",[v._v("10")]),v._v(" 当除数，然后将 "),e("code",[v._v("num")]),v._v(" 对除数 "),e("code",[v._v("10")]),v._v(" 取余得到的数字作为后续的最高位即可。")])]),v._v(" "),e("p",[v._v("相关代码如下：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("var isPalindrome = function(x) {\n    if (x === 0) return true;\n    if (x < 0 || x % 10 === 0) return false;\n    let reverse = 0;\n    let rest = x;\n    while (res >= 10) {\n        reverse = reverse * 10 + res % 10;\n        res = Math.floor(res / 10);\n    }\n    return (reverse * 10 + res) === x;\n};\n")])])]),e("p",[v._v("这种方式考验大家对数学的敏感度以及逻辑能力。")]),v._v(" "),e("h2",{attrs:{id:"整数反转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整数反转"}},[v._v("#")]),v._v(" 整数反转")]),v._v(" "),e("p",[v._v("这是力扣第 7 题")]),v._v(" "),e("blockquote",[e("p",[v._v("给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围  [−231,  231 − 1] ，就返回 0。")]),v._v(" "),e("p",[v._v("假设环境不允许存储 64 位整数（有符号或无符号）。")])]),v._v(" "),e("h2",{attrs:{id:"解题思路-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-3"}},[v._v("#")]),v._v(" 解题思路")]),v._v(" "),e("p",[v._v("这道题属于中等难度的题目，第一眼看过去和反转字符串很像，但是仔细一看还是有很大区别的。不过既然觉得和反转字符串类似，那为何不把它变成字符串来求解呢？因此，第一种最容易想到的解题思路诞生了 —— 转换为字符串后反转。")]),v._v(" "),e("h3",{attrs:{id:"number-转换-string-法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#number-转换-string-法"}},[v._v("#")]),v._v(" Number 转换 String 法")]),v._v(" "),e("p",[v._v("看到小标题，应该大概知道是什么思路了吧。把整数 "),e("code",[v._v("X")]),v._v(" 先变成字符串 "),e("code",[v._v("Y")]),v._v("，因为字符串的反转题目已经做过，或者说已经有思路，因此这样转换是比较直接的方式。至于 "),e("code",[v._v("Number")]),v._v(" 如何转为为 "),e("code",[v._v("String")]),v._v("，在网上搜一下有很多方式，比如 "),e("code",[v._v("toString")]),v._v("、"),e("code",[v._v("newString（）")]),v._v(" 等等，这里我们使用 "),e("code",[v._v("toString")]),v._v(" 方式，是用的比较多的一种转换方法。")]),v._v(" "),e("p",[v._v("整体思路如下：")]),v._v(" "),e("ul",[e("li",[v._v("将整数 "),e("code",[v._v("X")]),v._v(" 转换为 "),e("code",[v._v("String")]),v._v(" 类型")]),v._v(" "),e("li",[v._v("然后用 "),e("code",[v._v("split")]),v._v(" 方法将 "),e("code",[v._v("String")]),v._v(" 类型分割成 "),e("code",[v._v("Array")]),v._v(" 对象")]),v._v(" "),e("li",[v._v("然后用 "),e("code",[v._v("Array")]),v._v(" 对象的 "),e("code",[v._v("reverse")]),v._v(" 方法进行翻转，这样就到达反转效果。到了这一步后，就需要重新之前的操作，将 "),e("code",[v._v("Array")]),v._v(" 对象变回 "),e("code",[v._v("String")]),v._v(" 类型，再将 "),e("code",[v._v("String")]),v._v(" 类型变回 "),e("code",[v._v("Number")]),v._v("。")]),v._v(" "),e("li",[v._v("分别用到 "),e("code",[v._v("Array")]),v._v(" 对象的 "),e("code",[v._v("join")]),v._v(" 方法和 "),e("code",[v._v("String")]),v._v(" 类型的 "),e("code",[v._v("parseInt")]),v._v(" 方法")]),v._v(" "),e("li",[v._v("最后用三目运算符 "),e("code",[v._v("return")]),v._v(" 最终结果")])]),v._v(" "),e("p",[v._v("相关代码如下：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v('var reverse = function (x) {\n    let y = parseInt(x.toString().split("").reverse().join(""));\n    if (x < 0)\n        y = - y;\n    return y > 2147483647 || y < -2147483648 ? 0 : y;\n};\n')])])]),e("p",[v._v("整体解题的流程可以理解成这样："),e("code",[v._v("Number")]),v._v(" 类型 -> "),e("code",[v._v("String")]),v._v(" 类型 -> "),e("code",[v._v("Array")]),v._v(" 类型 -> "),e("code",[v._v("String")]),v._v(" 类型 -> "),e("code",[v._v("Number")]),v._v(" 类型。由此可见解题流程也能看成是一个被反转的对称的过程。")])])}),[],!1,null,null,null);e.default=r.exports}}]);