(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{427:function(e,t,n){"use strict";n.r(t);var v=n(2),a=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"相交链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相交链表"}},[e._v("#")]),e._v(" 相交链表")]),e._v(" "),t("p",[e._v("这是力扣 160 题")]),e._v(" "),t("blockquote",[t("p",[e._v("给你两个单链表的头节点  headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n"),t("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb1dfd3e3c9347daabf768bb89e09d0f~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}}),e._v("\n题目数据  "),t("strong",[e._v("保证")]),e._v("  整个链式结构中不存在环。\n"),t("strong",[e._v("注意")]),e._v("，函数返回结果后，链表必须  "),t("strong",[e._v("保持其原始结构")]),e._v(" 。")])]),e._v(" "),t("h2",{attrs:{id:"解题思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路"}},[e._v("#")]),e._v(" 解题思路")]),e._v(" "),t("p",[e._v("这道题目并不是很难，但是我们要弄清楚这里相交的交点。我们需要注意，这里相交是指指针相等，而不是数值相等。我第一次做这题的时候，就误以为是数值相等，就这样稀里糊涂地做起来了，结果可想而知，未通过。弄清楚了这个，接下来就用我们的老朋友 — 双指针，来介绍一下这题的思路。")]),e._v(" "),t("h3",{attrs:{id:"双指针解法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双指针解法"}},[e._v("#")]),e._v(" 双指针解法")]),e._v(" "),t("p",[e._v("创建两个指针 "),t("code",[e._v("a")]),e._v(" 和 "),t("code",[e._v("b")]),e._v("，分别指向 "),t("code",[e._v("headA")]),e._v("、"),t("code",[e._v("headB")]),e._v("，然后当 "),t("code",[e._v("a")]),e._v(" 与 "),t("code",[e._v("b")]),e._v(" 不相等时，先遍历各自节点部分。如果存在公共部分，再遍历公共部分，接着遍历非公共部分，直到 "),t("code",[e._v("a")]),e._v(" 等于 "),t("code",[e._v("b")]),e._v("，则找到 "),t("code",[e._v("a")]),e._v(" 为相交点。否则遍历完各自节点均为有公共部分，说明不相交。用大白话来表示就是：把它当成两个人赛跑，速度相同，最后终点也相同。若有相遇（相交）的情况，说明最后到终点的一段路程也相同。如不相遇（相交），则最后同时到达终点。每一步操作都需要同时更新 "),t("code",[e._v("a")]),e._v(" 和 "),t("code",[e._v("b")]),e._v(" 两个指针。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("a")]),e._v(" 与 "),t("code",[e._v("b")]),e._v(" 不相等，一起移动，遍历完自己的链表后再去遍历对方的链表。")])]),e._v(" "),t("p",[e._v("这道题不难，但是需要理解，理解这个相交的情况，理解如何处理相交。动手多画，你就会有所收获。")]),e._v(" "),t("p",[e._v("相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var getIntersectionNode = function(headA, headB) {\n    let a = headA, b = headB;\n    while(a !== b) {\n        a = a ? a.next : headB;\n        b = b ? b.next : headA;\n    }\n    return a;\n};\n")])])]),t("h2",{attrs:{id:"删除链表的倒数第-n-个结点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除链表的倒数第-n-个结点"}},[e._v("#")]),e._v(" 删除链表的倒数第 N 个结点")]),e._v(" "),t("p",[e._v("这是力扣 19 题")]),e._v(" "),t("blockquote",[t("p",[e._v("给你一个链表，删除链表的倒数第  "),t("code",[e._v("n")]),e._v(" 个结点，并且返回链表的头结点。")])]),e._v(" "),t("h2",{attrs:{id:"解题思路-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-2"}},[e._v("#")]),e._v(" 解题思路")]),e._v(" "),t("p",[e._v("这又是一道中等难度的题，但是其实并不是特别难，因为这是一道有关双指针的经典应用。双指针在数组那块已经讲过很多次了，这是第一次运用到链表上。在这道题目上，可以将双指针的作用发挥到淋漓尽致，因此通过这道题目可以更好地帮助大家理解双指针解法以及这种解法在链表上的应用。")]),e._v(" "),t("h3",{attrs:{id:"双指针解法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双指针解法-2"}},[e._v("#")]),e._v(" 双指针解法")]),e._v(" "),t("p",[e._v("这道题目里双指针又可以称为快慢指针，定义 "),t("code",[e._v("slow")]),e._v(" 和 "),t("code",[e._v("fast")]),e._v(" 两个指针来移动（在下面代码中，我用 "),t("code",[e._v("n1")]),e._v(" 和 "),t("code",[e._v("n2")]),e._v(" 来表示 "),t("code",[e._v("slow")]),e._v(" 和 "),t("code",[e._v("fast")]),e._v(" 两个指针）。")]),e._v(" "),t("p",[e._v("除了两个指针之外，这里又需要使用到虚拟头节点，使用虚拟头节点的好处就不用我多说了，它方便处理删除实际头节点的逻辑。我们让定义好的两个指针初始值为虚拟头节点。如果要删除倒数第 "),t("code",[e._v("N")]),e._v(" 个节点，首先让 "),t("code",[e._v("fast")]),e._v(" 指针移动 "),t("code",[e._v("N")]),e._v(" 步，然后让 "),t("code",[e._v("fast")]),e._v(" 指针和 "),t("code",[e._v("slow")]),e._v(" 指针同时移动，直到 "),t("code",[e._v("fast")]),e._v(" 指针指向链表末尾。删掉 "),t("code",[e._v("slow")]),e._v(" 指针所指向的节点就可以了。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("fast")]),e._v(" 和 "),t("code",[e._v("slow")]),e._v(" 同时移动，直到 "),t("code",[e._v("fast")]),e._v(" 指向 "),t("code",[e._v("null")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" while(fast!==null){\n        slow = slow.next;\n        fast = fast.next;\n    }\n")])])]),t("ul",[t("li",[e._v("通过 "),t("code",[e._v("slow")]),e._v(" 删除 "),t("code",[e._v("slow->next")]),e._v(" 的节点。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("slow.next = slow.next.next;\n")])])]),t("p",[e._v("这就是整个过程的大体思路了，建议可以在纸上多画画，多模拟几遍操作，就能想得更清楚了。链表的题目如果能在纸上通过不断模拟想清楚，就能简单很多。根据以上步骤就能轻易写出代码。")]),e._v(" "),t("p",[e._v("相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// n1和n2代表快慢指针\n\nvar removeNthFromEnd = function(head, n) {\n    let dummy = new ListNode();\n    dummy.next = head;\n    let n1 = dummy;\n    let n2 = dummy;\n    for(let i=0;i<=n;i++){\n        n2 = n2.next;\n    }\n    while(n2!==null){\n        n1 = n1.next;\n        n2 = n2.next;\n    }\n    n1.next = n1.next.next;\n    return dummy.next;\n};\n")])])]),t("h2",{attrs:{id:"两两交换链表中的节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两两交换链表中的节点"}},[e._v("#")]),e._v(" 两两交换链表中的节点")]),e._v(" "),t("p",[e._v("这是力扣 24 题")]),e._v(" "),t("blockquote",[t("p",[e._v("给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。")])]),e._v(" "),t("h2",{attrs:{id:"解题思路-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解题思路-3"}},[e._v("#")]),e._v(" 解题思路")]),e._v(" "),t("p",[e._v("这是一道中等难度的题目，是有一点点难度的。对于链表类的题目，我的建议是"),t("strong",[e._v("动手画图")]),e._v("，将链表画出来，然后根据题目要求来模拟链表的一系列操作。对于这道题而言，画图能够清晰地模拟出思路")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfaa0d5460864f60a0b318cb7f5e9026~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18aa1eb04f6447f18369d3dc5c7ae5ab~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),e._v(" "),t("p",[e._v("题目要求的是交换相邻的两个节点，并且要求不修改节点内的值，因此如上面画出的图所示。"),t("code",[e._v("current")]),e._v(" 是创建的头节点。在链表的题目中，创建虚拟头节点对解题十分方便，这里让 "),t("code",[e._v("current")]),e._v(" 指向虚拟头节点。")]),e._v(" "),t("p",[e._v("解题思路如下：")]),e._v(" "),t("ul",[t("li",[e._v("首先定义一个虚拟头节点 "),t("code",[e._v("dumy")])]),e._v(" "),t("li",[e._v("然后用 "),t("code",[e._v("current")]),e._v(" 来代表头节点，并让 "),t("code",[e._v("current")]),e._v(" 指向虚拟头节点，"),t("code",[e._v("current -> n1 -> n2")]),e._v(" 需要被转换成 "),t("code",[e._v("current -> n2 -> n1")])]),e._v(" "),t("li",[e._v("其次 "),t("code",[e._v("current")]),e._v(" 指向 "),t("code",[e._v("n1")]),e._v("，然后再去反转 "),t("code",[e._v("n1")]),e._v(" 之后的节点")]),e._v(" "),t("li",[e._v("最后返回创建的虚拟头节点的 "),t("code",[e._v("next")])])]),e._v(" "),t("p",[e._v("相关代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var swapPairs = function(head) {\n    let dummy = new ListNode();\n    dummy.next = head;\n    let current = dummy;\n    while(current.next!==null&&current.next.next!==null){\n        let n1 = current.next;\n        let n2 = current.next.next;\n        current.next = n2;\n        n1.next = n2.next;\n        n2.next = n1;\n        current = n1;\n    }\n    return dummy.next;\n};\n")])])]),t("p",[e._v("光看代码可能会有些难以完全理解，建议大家可以"),t("strong",[e._v("动手画图")]),e._v("去模拟这些交换、移动的与指针相关的操作，否则在不画图的情况下仅仅靠去想这些指针的操作，会很容易打乱顺序。这道题难度属于中等，略微会有一点点难度，所以可以多看看它并理解它。理解这道题也可以帮助大家更好地理解链表。")])])}),[],!1,null,null,null);t.default=a.exports}}]);